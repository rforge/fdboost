% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/crossvalidation.R
\name{cvMa}
\alias{cvLong}
\alias{cvMa}
\alias{validateFDboost}
\title{Cross-Validation and Bootstrapping over Curves}
\usage{
cvMa(ydim, weights = NULL, type = c("bootstrap", "kfold", "subsampling",
  "curves"), B = ifelse(type == "kfold", 10, 25), prob = 0.5,
  strata = NULL, id = NULL)

cvLong(id, weights = rep(1, l = length(id)), type = c("bootstrap", "kfold",
  "subsampling", "curves"), B = ifelse(type == "kfold", 10, 25), prob = 0.5,
  strata = NULL)

validateFDboost(object, response = NULL, folds = cv(rep(1, object$ydim[1]),
  type = "bootstrap"), grid = 1:mstop(object), getCoefCV = TRUE,
  riskopt = c("mean", "median"), mrdDelete = 0, refitSmoothOffset = TRUE,
  showProgress = TRUE, ...)
}
\arguments{
\item{ydim}{dimensions of response-matrix}

\item{weights}{a numeric vector of weights for the model to be cross-validated.
if weights=NULL all weights are taken to be 1.}

\item{type}{character argument for specifying the cross-validation
method. Currently (stratified) bootstrap, k-fold cross-validation
and subsampling are implemented.
The argument curves implies that a cross-validation leaving out one curve at
a time is performed.}

\item{B}{number of folds, per default 25 for \code{bootstrap} and
\code{subsampling} and 10 for \code{kfold}.}

\item{prob}{percentage of observations to be included in the learning samples
for subsampling.}

\item{strata}{a factor of the same length as \code{weights} for stratification.}

\item{id}{id-variable to sample upon ids instead of sampling single observations.
(Only interesting in the case that several observations per individual were made.)}

\item{object}{fitted FDboost-object}

\item{response}{you can specify a response vector to calculate predictions errors.
Defaults to NULL which means that the response of the fitted model is used.}

\item{folds}{a weight matrix with number of rows equal to the number of observed trajectories.}

\item{grid}{the grid over which the optimal mstop is searched}

\item{getCoefCV}{logical, defaults to TRUE Should the coefficients and predictions
be computed for all the models on the sampled data?}

\item{riskopt}{how is the optimal stopping iteration determined. Defaults to the mean
but median is possible as well.}

\item{mrdDelete}{Delete values that are mrdDelete percent smaller then the mean
of the response. Defaults to 0 which means that only response values being 0
are not used in the calculation of the MRD (= mean relative deviation)}

\item{refitSmoothOffset}{logical, should the offset be refitted in each learning sample?
Defaults to TRUE.}

\item{showProgress}{logigal, default to TRUE
In \code{\link[mboost]{cvrisk}} the offset of the original model \code{object} is used.}

\item{...}{further arguments passed to mclapply}
}
\value{
\code{cvMa} and \code{cvLong} return a matrix of weights to be used in \code{cvrisk}.
\code{validateFDboost} returns an validateFDboost-object, which is a named list containing:
\item{response}{the response}
\item{yind}{the observation points of the response}
\item{id}{the id variable of the response}
\item{folds}{folds that were used}
\item{grid}{grid of possible numbers of boosting iterations}
\item{coefCV}{if \code{getCoefCV} is TRUE the estimated coefficient functions in the folds}
\item{predCV}{if \code{getCoefCV} is TRUE the out-of-bag predicted values of the response}
\item{oobpreds}{if the type of folds is curves the out-of-bag predictions for each trajectory}
\item{oobrisk}{the out-of-bag risk}
\item{oobriskMean}{the out-of-bag risk at the minimal mean risk}
\item{oobmse}{the out-of-bag mean squared error (MSE)}
\item{oobrelMSE}{the out-of-bag relative mean squared error (relMSE)}
\item{oobmrd}{the out-of-bag mean relative deviation (MRD)}
\item{oobrisk0}{the out-of-bag risk without consideration of integration weights}
\item{oobmse0}{the out-of-bag mean squared error (MSE) without consideration of integration weights}
\item{oobmrd0}{the out-of-bag mean relative deviation (MRD) without consideration of integration weights}
}
\description{
Cross-Validation and bootstrapping over curves to compute the empirical risk for
hyper-parameter selection and to compute resampled coefficients and predictions for
the models.
}
\details{
The function \code{validateFDboost} calculates honest estimates
of prediction errors as the curves/observations
that should be predicted are not part of the model fit.
The functions \code{cvMa} and \code{cvLong} can be used to build an appropriate
weight matrix to be used with \code{cvrisk}. The function \code{cvMa} is appropriate for
responses observed over a regular grid. The function \code{cvLong} for responsese that
are observed over a irregular grid.
Note, that the function \code{validateFDboost} expects folds that give weights
per trajectory and that \code{cvrisk} expectes folds that give weights for single observations.
In \code{cvMa} and \code{cvLong} trajectories are sampled. The probability for each
trajectory to enter a fold is equal over all trajectories.
If \code{strata} is defined
sampling is performed in each stratum separately thus preserving
the distribution of the \code{strata} variable in each fold.
If \code{id} is defined sampling is performed on the level of \code{id}
thus sampling individuals.
}
\note{
Use argument \code{mc.cores = 1L} to set the numbers of cores that is used in
parallel computation. On Windows only 1 core is possible, \code{mc.cores = 1}, which is the default.
}
\examples{
Ytest <- matrix(rnorm(15), ncol=3) # 5 trajectories, each with 3 observations
cvMa(ydim=c(5,3), type="bootstrap", B=4)

data("viscosity", package = "FDboost")
## set time-interval that should be modeled
interval <- "101"

## model time until "interval" and take log() of viscosity
end <- which(viscosity$timeAll==as.numeric(interval))
viscosity$vis <- log(viscosity$visAll[,1:end])
viscosity$time <- viscosity$timeAll[1:end]
# with(viscosity, funplot(time, vis, pch=16, cex=0.2))

## fit median regression model with 200 boosting iterations,
## step-length 0.2 and
## smooth time-specific offset
mod <- FDboost(vis ~ 1 + bols(T_C) + bols(T_A),
               timeformula=~bbs(time, lambda=100),
               numInt="Riemann", family=QuantReg(),
               offset=NULL, offset_control = o_control(k_min = 9),
               data=viscosity, control=boost_control(mstop = 100, nu = 0.4))

\dontrun{
## for the example B is set to a small value so that bootstrap is faster
val1 <- validateFDboost(mod, folds=cv(rep(1, 64), B=3) )
# plot(val1)
mstop(val1)
}
}
\seealso{
\code{\link{cvrisk}} to perform cross-validation.
}

